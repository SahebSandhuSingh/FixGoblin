# Buggy Python sample - 300 lines, many intentional bugs sprinkled
# Author: Generated for testing
# Purpose: include intentional bugs across the file

import math
import random
from typing import List, Dict, Any

def safe_add(a, b):
    """Return the sum of a and b"""
    return a + b

def buggy_division(a, b):
    # Intentionally missing check for zero
    return a / b

def greet(name: str) -> str:
    return f"Hello, {name}!"

class Counter:
    def __init__(self, start=0):
        self.value = start

    def inc(self):
        self.value += 1

    def get(self):
        return self.value

# End of block 1


def find_max(nums: List[int]) -> int:
    if not nums:
        raise ValueError("Empty list")
    max_v = nums[0]
    for n in nums:
        if n > max_v:
            max_v = n
    return max_v

def buggy_sort(nums: List[int]) -> List[int]:
    # A buggy bubble sort with an off-by-one
    n = len(nums)
    for i in range(n):
        for j in range(0, n - i):  # should be n-i-1
            if nums[j] > nums[j + 1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
    return nums

def is_prime(n: int) -> bool:
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):  # bug: math.sqrt returns float (logic note)
        if n % i == 0:
            return False
    return True

# helper
def identity(x): return x


def generate_sequence(n: int) -> List[int]:
    seq = []
    for i in range(n):
        seq.append(i * i)
    return seq

def buggy_merge(a: List[int], b: List[int]) -> List[int]:
    # Merge assuming a and b sorted, but uses wrong indices
    i, j = 0, 0
    out = []
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            out.append(a[i])
            i += 1
        else:
            out.append(b[j])
            j += 1
    # remaining
    while i <= len(a):  # bug: should be < len(a)
        out.append(a[i])
        i += 1
    while j < len(b):
        out.append(b[j])
        j += 1
    return out

def format_point(x, y):
    return f"({x},{y})"

# End of block 3


class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def birthday(self):
        self.age += 1

    def __repr__(self):
        return f"Person({self.name}, {self.age})"

def parse_int(s: str) -> int:
    try:
        return int(s)
    except ValueError:
        return None  # bug: should raise or return a sentinel (None changes type expectations)

def buggy_counter_factory(n):
    funcs = []
    for i in range(n):
        def f():
            return i  # bug: late binding captures i (all functions will return n-1)
        funcs.append(f)
    return funcs

# small util
def noop(): pass


def compute_stats(nums: List[float]) -> Dict[str, float]:
    if not nums:
        return {"mean": 0.0, "min": 0.0, "max": 0.0}
    s = sum(nums)
    mean = s / len(nums)
    return {"mean": mean, "min": min(nums), "max": max(nums)}

def buggy_power(x, y):
    # mistakenly uses multiplication instead of exponent
    return x * y

def fib(n: int) -> int:
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fib(n-1) + fib(n-2)

def buggy_map(func, items):
    out = []
    for i in items:
        out.append(func)  # bug: should call func(i)
    return out

# formatting
def pretty(s):
    return str(s).upper()


# I/O helpers (no real I/O to keep this self contained)
def read_config() -> Dict[str, Any]:
    # pretend config
    return {"retries": 3, "timeout": 5}

def buggy_path_join(a, b):
    # uses + without separator
    return a + b

def serialize(obj):
    # naive serializer
    try:
        return str(obj)
    except Exception as e:
        return "{}"

def buggy_deserialize(s):
    # assumes eval is safe (it's not) and typo
    return ecal(s)  # bug: misspelled eval -> NameError

def clamp(x, low, high):
    return max(low, min(x, high))

def buggy_shuffle(lst):
    # tries to use random.shuffle incorrectly
    return random.shuffle(lst)  # bug: shuffle returns None (in-place)

# End block


def compute_factorial(n: int) -> int:
    if n < 0:
        raise ValueError("Negative")
    res = 1
    for i in range(1, n+1):
        res *= i
    return res

def buggy_linear_search(arr, target):
    # returns incorrect index when found at position 0
    for i in range(1, len(arr)):  # bug: starts at 1, misses index 0
        if arr[i] == target:
            return i
    return -1

def compose(f, g):
    return lambda x: f(g(x))

def buggy_counter():
    # mutable default trap
    def add(item, lst=[]):
        lst.append(item)
        return lst
    return add

# small dataset
SAMPLE = [3, 1, 4, 1, 5, 9, 2, 6]


def analyze_text(text: str) -> Dict[str, int]:
    words = text.split()
    counts = {}
    for w in words:
        counts[w] = counts.get(w, 0) + 1
    return counts

def buggy_replace(s, a, b):
    # uses wrong method name
    return s.repace(a, b)  # bug: misspelled replace -> AttributeError

def to_celsius(f):
    return (f - 32) * 5 / 9

def buggy_average(nums):
    # divides by wrong variable
    return sum(nums) / n  # bug: n undefined -> NameError

def repeat(s, n):
    return s * n

# End block


def buggy_unpack(tup):
    # expects two but may get three
    a, b = tup  # bug: ValueError if tup has !=2
    return a, b


def connect_simulated(host: str, port: int):
    # fake connection object
    return {"host": host, "port": port, "status": "connected"}

def buggy_send(packet):
    # tries to index a dict like a list
    return packet[0]  # bug: may raise KeyError or TypeError depending on packet type

class Widget:
    def __init__(self, name):
        self.name = name

    def render(self):
        return f"<widget>{self.name}</widget>"

def buggy_time_sleep(sec):
    # typo in function name
    tim.sleep(sec)  # bug: module name typo -> NameError

# small math
def hypotenuse(a, b):
    return math.sqrt(a*a + b*b)


def buggy_pow(a, b):
    # uses loop but off-by-one
    res = 1
    for i in range(1, b):  # bug: starts at 1, gives a^(b-1)
        res *= a
    return res


def main():
    print("Starting test script")

    # test addition
    print("2+3=", safe_add(2, 3))

    # test division (this will raise if b==0)
    try:
        print("10/2=", buggy_division(10, 2))
    except Exception as e:
        print("Division error:", e)

    # test sort
    data = [5, 3, 1, 4, 2]
    print("Sorted:", buggy_sort(data.copy()))

    # test prime
    print("7 is prime?", is_prime(7))

    # test merge
    print("Merge:", buggy_merge([1,3,5], [2,4,6]))

    # test counter factory
    funcs = buggy_counter_factory(3)
    print("counter factory outputs:", [f() for f in funcs])

    # more tests
    print("Done")

if __name__ == "__main__":
    main()