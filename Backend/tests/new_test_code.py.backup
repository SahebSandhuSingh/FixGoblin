# Contact Manager Demo (approx. 200 lines)
# Contains a few small deliberate bugs for testing an autonomous debugger.

import json
import datetime
import random
import re
from typing import List, Optional

class Contact:
    def __init__(self, first_name: str, last_name: str, email: str, phone: Optional[str]=None, tags: Optional[List[str]]=None):
        self.first_name = first_name.strip()
        self.last_name = last_name.strip()
        self.email = email.strip()
        self.phone = phone.strip() if phone else None
        self.tags = tags or []
        self.created_at = datetime.datetime.now()

    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    def to_dict(self):
        return {
            "first_name": self.first_name,
            "last_name": self.last_name,
            "email": self.email,
            "phone": self.phone,
            "tags": self.tags,
            "created_at": self.created_at.isoformat()
        }

    @staticmethod
    def from_dict(d):
        c = Contact(d['first_name'], d['last_name'], d['email'], d.get('phone'), d.get('tags', []))
        c.created_at = datetime.datetime.fromisoformat(d.get('created_at'))
        return c

    def __str__(self):
        phone = self.phone if self.phone else "No phone"
        tags = ",".join(self.tags) if self.tags else "No tags"
        return f"{self.full_name()} <{self.email}> | {phone} | {tags}"

class ContactManager:
    def __init__(self):
        self.contacts: List[Contact] = []

    def add_contact(self, contact: Contact):
        if not isinstance(contact, Contact):
            raise TypeError("Must add Contact instance")
        # prevent duplicate emails
        for c in self.contacts:
            if c.email.lower() == contact.email.lower():
                return False
        self.contacts.append(contact)
        return True

    def remove_contact_by_email(self, email: str):
        for i, c in enumerate(self.contacts):
            if c.email.lower() == email.lower():
                return self.contacts.pop(i)
        raise ValueError("Contact not found")

    def find_by_name(self, query: str):
        q = query.lower()
        return [c for c in self.contacts if q in c.first_name.lower() or q in c.last_name.lower()]

    def find_by_tag(self, tag: str):
        return [c for c in self.contacts if tag.lower() in (t.lower() for t in c.tags)]

    def sort_by_name(self):
        self.contacts.sort(key=lambda c: (c.last_name.lower(), c.first_name.lower()))

    def sort_by_created(self, reverse=False):
        self.contacts.sort(key=lambda c: c.created_at, reverse=reverse)

    def save(self, path: str):
        with open(path, "w") as f:
            data = [c.to_dict() for c in self.contacts]
            json.dump(data, f, indent=2)

    def load(self, path: str):
        try:
            with open(path, "r") as f:
                raw = json.load(f)
            self.contacts = [Contact.from_dict(d) for d in raw]
        except FileNotFoundError:
            self.contacts = []

    def paginate(self, page_size=10):
        # returns list of pages (each page is a list of contacts)
        pages = []
        for i in range(0, len(self.contacts), page_size):
            pages.append(self.contacts[i:i+page_size])
        return pages

    def __str__(self):
        return "\n".join(f"{i+1}: {str(c)}" for i, c in enumerate(self.contacts))

# Utility functions
def is_valid_email(email: str) -> bool:
    # simple regex
    pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"
    return re.match(pattern, email) is not None

def random_sample_contacts(n=20) -> ContactManager:
    first = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Hank", "Ivy", "Jack"]
    last = ["Anderson", "Brown", "Clark", "Davis", "Evans", "Ford", "Green", "Hill", "Irwin", "Jones"]
    tags_pool = [["friend"], ["work"], ["family"], ["gym","friend"], []]

    cm = ContactManager()
    for i in range(n):
        fn = random.choice(first)
        ln = random.choice(last)
        email = f"{fn.lower()}.{ln.lower()}{i}@example.com"
        phone = f"+1-555-{1000 + i}"
        tags = random.choice(tags_pool)
        c = Contact(fn, ln, email, phone, tags)
        cm.add_contact(c)
    return cm

# Some sample business logic functions that may contain subtle bugs:
def merge_managers(primary: ContactManager, secondary: ContactManager):
    # merge contacts from secondary into primary, avoid duplicates (by email)
    added = 0
    for c in secondary.contacts:
        if not any(pc.email.lower() == c.email.lower() for pc in primary.contacts):
            primary.add_contact(c)
            added += 1
    return added

def export_emails(cm: ContactManager) -> List[str]:
    # collect all emails
    return [c.email for c in cm.contacts if c.email]

def upcoming_birthdays(cm: ContactManager, within_days=30):
    # assume tag 'birthdate:YYYY-MM-DD' in tags indicates birthday
    res = []
    today = datetime.date.today()
    for c in cm.contacts:
        for t in c.tags:
            if t.startswith("birthdate:"):
                try:
                    date_str = t.split(":", 1)[1]
                    bd = datetime.date.fromisoformat(date_str)
                    # next birthday this year
                    next_bd = bd.replace(year=today.year)
                    if next_bd < today:
                        next_bd = bd.replace(year=today.year + 1)
                    delta = (next_bd - today).days
                    if 0 <= delta <= within_days:
                        res.append((c, delta))
                except Exception:
                    pass
    return sorted(res, key=lambda x: x[1])

def merge_duplicates(cm: ContactManager):
    # find contacts with same full name and merge tags and phones
    seen = {}
    new_list = []
    for c in cm.contacts:
        key = c.full_name().lower()
        if key in seen:
            orig = seen[key]
            # merge tags
            for t in c.tags:
                if t not in orig.tags:
                    orig.tags.append(t)
            # prefer original phone if absent
            if not orig.phone and c.phone:
                orig.phone = c.phone
        else:
            seen[key] = c
            new_list.append(c)
    cm.contacts = new_list

def compute_stats(cm: ContactManager):
    total = len(cm.contacts)
    with_phone = sum(1 for c in cm.contacts if c.phone)
    tag_counts = {}
    for c in cm.contacts:
        for t in c.tags:
            tag_counts[t] = tag_counts.get(t, 0) + 1
    avg_per_tag = {k: v / total for k, v in tag_counts.items()}
    return {
        "total": total,
        "with_phone": with_phone,
        "tags": tag_counts,
        "avg_per_tag": avg_per_tag
    }

# CLI Simulation / Demo usage
def demo_workflow():
    cm = random_sample_contacts(25)
    # add some birthdays
    cm.contacts[0].tags.append("birthdate:1990-12-05")
    cm.contacts[3].tags.append("birthdate:1985-11-30")
    cm.contacts[7].tags.append("birthdate:2000-12-02")
    cm.contacts[10].tags.append("birthdate:1975-01-15")

    print("=== CONTACTS SAMPLE ===")
    print(cm)
    print("\n=== SORTED BY NAME ===")
    cm.sort_by_name()
    print(cm)

    print("\n=== PAGINATE (page size 5) ===")
    pages = cm.paginate(5)
    for idx, p in enumerate(pages):
        print(f"-- Page {idx+1} --")
        for c in p:
            print(c.full_name())

    print("\n=== UPCOMING BIRTHDAYS ===")
    bds = upcoming_birthdays(cm, within_days=60)
    for c, days in bds:
        print(f"{c.full_name()} in {days} days")

    print("\n=== MERGE DUPLICATES ===")
    # create a duplicate
    dup = Contact(cm.contacts[0].first_name, cm.contacts[0].last_name, f"dup{cm.contacts[0].email}", None, ["colleague"])
    cm.add_contact(dup)
    print("Before merge:", len(cm.contacts))
    merge_duplicates(cm)
    print("After merge:", len(cm.contacts))

    print("\n=== COMPUTE STATS ===")
    stats = compute_stats(cm)
    print(stats)

    print("\n=== EXPORT EMAILS ===")
    emails = export_emails(cm)
    print(", ".join(emails[:10]))

    print("\n=== SAVE & LOAD ===")
    cm.save("contacts_demo.json")
    cm2 = ContactManager()
    cm2.load("contacts_demo.json")
    print("Loaded count:", len(cm2.contacts))

# A few intentionally buggy helper functions for testing fixes
def sum_first_n(n):
    # Intentional off-by-one bug: should sum 1..n inclusive
    s = 0
    for i in range(1, n):
        s += i
    return s

def safe_divide(a, b):
    # returns None when division by zero occurs, but we want 0 or raise
    try:
        return a / b
    except ZeroDivisionError:
        return None

def find_max_index(values):
    # returns index of max value; bug when values empty
    max_i = 0
    for i, v in enumerate(values):
        if v > values[max_i]:
            max_i = i
    return max_i

# Main entry
def main():
    print("Starting Contact Manager Demo")
    demo_workflow()
    print("\n=== TEST HELPERS ===")
    print("Sum of first 10 (expect 55):", sum_first_n(10))
    print("Safe divide 10/2:", safe_divide(10, 2))
    print("Safe divide 10/0:", safe_divide(10, 0))
    print("Max index of [3,1,4,2]:", find_max_index([3,1,4,2]))
    try:
        print("Max index of []:", find_max_index([]))
    except Exception as e:
        print("Handled exception for empty list:", e)

if __name__ == "__main__":
    main()
