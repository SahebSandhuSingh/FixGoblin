{
  "success": true,
  "final_code": "# Contact Manager Demo (approx. 200 lines)\n# Contains a few small deliberate bugs for testing an autonomous debugger.\n\nimport json\nimport datetime\nimport random\nimport re\nfrom typing import List, Optional\n\nclass Contact:\n    def __init__(self, first_name: str, last_name: str, email: str, phone: Optional[str]=None, tags: Optional[List[str]]=None):\n        self.first_name = first_name.strip()\n        self.last_name = last_name.strip()\n        self.email = email.strip()\n        self.phone = phone.strip() if phone else None\n        self.tags = tags or []\n        self.created_at = datetime.datetime.now()\n\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n    def to_dict(self):\n        return {\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"email\": self.email,\n            \"phone\": self.phone,\n            \"tags\": self.tags,\n            \"created_at\": self.created_at.isoformat()\n        }\n\n    @staticmethod\n    def from_dict(d):\n        c = Contact(d['first_name'], d['last_name'], d['email'], d.get('phone'), d.get('tags', []))\n        c.created_at = datetime.datetime.fromisoformat(d.get('created_at'))\n        return c\n\n    def __str__(self):\n        phone = self.phone if self.phone else \"No phone\"\n        tags = \",\".join(self.tags) if self.tags else \"No tags\"\n        return f\"{self.full_name()} <{self.email}> | {phone} | {tags}\"\n\nclass ContactManager:\n    def __init__(self):\n        self.contacts: List[Contact] = []\n\n    def add_contact(self, contact: Contact):\n        if not isinstance(contact, Contact):\n            raise TypeError(\"Must add Contact instance\")\n        # prevent duplicate emails\n        for c in self.contacts:\n            if c.email.lower() == contact.email.lower():\n                return False\n        self.contacts.append(contact)\n        return True\n\n    def remove_contact_by_email(self, email: str):\n        for i, c in enumerate(self.contacts):\n            if c.email.lower() == email.lower():\n                return self.contacts.pop(i)\n        raise ValueError(\"Contact not found\")\n\n    def find_by_name(self, query: str):\n        q = query.lower()\n        return [c for c in self.contacts if q in c.first_name.lower() or q in c.last_name.lower()]\n\n    def find_by_tag(self, tag: str):\n        return [c for c in self.contacts if tag.lower() in (t.lower() for t in c.tags)]\n\n    def sort_by_name(self):\n        self.contacts.sort(key=lambda c: (c.last_name.lower(), c.first_name.lower()))\n\n    def sort_by_created(self, reverse=False):\n        self.contacts.sort(key=lambda c: c.created_at, reverse=reverse)\n\n    def save(self, path: str):\n        with open(path, \"w\") as f:\n            data = [c.to_dict() for c in self.contacts]\n            json.dump(data, f, indent=2)\n\n    def load(self, path: str):\n        try:\n            with open(path, \"r\") as f:\n                raw = json.load(f)\n            self.contacts = [Contact.from_dict(d) for d in raw]\n        except FileNotFoundError:\n            self.contacts = []\n\n    def paginate(self, page_size=10):\n        # returns list of pages (each page is a list of contacts)\n        pages = []\n        for i in range(0, len(self.contacts), page_size):\n            pages.append(self.contacts[i:i+page_size])\n        return pages\n\n    def __str__(self):\n        return \"\\n\".join(f\"{i+1}: {str(c)}\" for i, c in enumerate(self.contacts))\n\n# Utility functions\ndef is_valid_email(email: str) -> bool:\n    # simple regex\n    pattern = r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\"\n    return re.match(pattern, email) is not None\n\ndef random_sample_contacts(n=20) -> ContactManager:\n    first = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\", \"Frank\", \"Grace\", \"Hank\", \"Ivy\", \"Jack\"]\n    last = [\"Anderson\", \"Brown\", \"Clark\", \"Davis\", \"Evans\", \"Ford\", \"Green\", \"Hill\", \"Irwin\", \"Jones\"]\n    tags_pool = [[\"friend\"], [\"work\"], [\"family\"], [\"gym\",\"friend\"], []]\n\n    cm = ContactManager()\n    for i in range(n):\n        fn = random.choice(first)\n        ln = random.choice(last)\n        email = f\"{fn.lower()}.{ln.lower()}{i}@example.com\"\n        phone = f\"+1-555-{1000 + i}\"\n        tags = random.choice(tags_pool)\n        c = Contact(fn, ln, email, phone, tags)\n        cm.add_contact(c)\n    return cm\n\n# Some sample business logic functions that may contain subtle bugs:\ndef merge_managers(primary: ContactManager, secondary: ContactManager):\n    # merge contacts from secondary into primary, avoid duplicates (by email)\n    added = 0\n    for c in secondary.contacts:\n        if not any(pc.email.lower() == c.email.lower() for pc in primary.contacts):\n            primary.add_contact(c)\n            added += 1\n    return added\n\ndef export_emails(cm: ContactManager) -> List[str]:\n    # collect all emails\n    return [c.email for c in cm.contacts if c.email]\n\ndef upcoming_birthdays(cm: ContactManager, within_days=30):\n    # assume tag 'birthdate:YYYY-MM-DD' in tags indicates birthday\n    res = []\n    today = datetime.date.today()\n    for c in cm.contacts:\n        for t in c.tags:\n            if t.startswith(\"birthdate:\"):\n                try:\n                    date_str = t.split(\":\", 1)[1]\n                    bd = datetime.date.fromisoformat(date_str)\n                    # next birthday this year\n                    next_bd = bd.replace(year=today.year)\n                    if next_bd < today:\n                        next_bd = bd.replace(year=today.year + 1)\n                    delta = (next_bd - today).days\n                    if 0 <= delta <= within_days:\n                        res.append((c, delta))\n                except Exception:\n                    pass\n    return sorted(res, key=lambda x: x[1])\n\ndef merge_duplicates(cm: ContactManager):\n    # find contacts with same full name and merge tags and phones\n    seen = {}\n    new_list = []\n    for c in cm.contacts:\n        key = c.full_name().lower()\n        if key in seen:\n            orig = seen[key]\n            # merge tags\n            for t in c.tags:\n                if t not in orig.tags:\n                    orig.tags.append(t)\n            # prefer original phone if absent\n            if not orig.phone and c.phone:\n                orig.phone = c.phone\n        else:\n            seen[key] = c\n            new_list.append(c)\n    cm.contacts = new_list\n\ndef compute_stats(cm: ContactManager):\n    total = len(cm.contacts)\n    with_phone = sum(1 for c in cm.contacts if c.phone)\n    tag_counts = {}\n    for c in cm.contacts:\n        for t in c.tags:\n            tag_counts[t] = tag_counts.get(t, 0) + 1\n    avg_per_tag = {k: v / total for k, v in tag_counts.items()}\n    return {\n        \"total\": total,\n        \"with_phone\": with_phone,\n        \"tags\": tag_counts,\n        \"avg_per_tag\": avg_per_tag\n    }\n\n# CLI Simulation / Demo usage\ndef demo_workflow():\n    cm = random_sample_contacts(25)\n    # add some birthdays\n    cm.contacts[0].tags.append(\"birthdate:1990-12-05\")\n    cm.contacts[3].tags.append(\"birthdate:1985-11-30\")\n    cm.contacts[7].tags.append(\"birthdate:2000-12-02\")\n    cm.contacts[10].tags.append(\"birthdate:1975-01-15\")\n\n    print(\"=== CONTACTS SAMPLE ===\")\n    print(cm)\n    print(\"\\n=== SORTED BY NAME ===\")\n    cm.sort_by_name()\n    print(cm)\n\n    print(\"\\n=== PAGINATE (page size 5) ===\")\n    pages = cm.paginate(5)\n    for idx, p in enumerate(pages):\n        print(f\"-- Page {idx+1} --\")\n        for c in p:\n            print(c.full_name())\n\n    print(\"\\n=== UPCOMING BIRTHDAYS ===\")\n    bds = upcoming_birthdays(cm, within_days=60)\n    for c, days in bds:\n        print(f\"{c.full_name()} in {days} days\")\n\n    print(\"\\n=== MERGE DUPLICATES ===\")\n    # create a duplicate\n    dup = Contact(cm.contacts[0].first_name, cm.contacts[0].last_name, f\"dup{cm.contacts[0].email}\", None, [\"colleague\"])\n    cm.add_contact(dup)\n    print(\"Before merge:\", len(cm.contacts))\n    merge_duplicates(cm)\n    print(\"After merge:\", len(cm.contacts))\n\n    print(\"\\n=== COMPUTE STATS ===\")\n    stats = compute_stats(cm)\n    print(stats)\n\n    print(\"\\n=== EXPORT EMAILS ===\")\n    emails = export_emails(cm)\n    print(\", \".join(emails[:10]))\n\n    print(\"\\n=== SAVE & LOAD ===\")\n    cm.save(\"contacts_demo.json\")\n    cm2 = ContactManager()\n    cm2.load(\"contacts_demo.json\")\n    print(\"Loaded count:\", len(cm2.contacts))\n\n# A few intentionally buggy helper functions for testing fixes\ndef sum_first_n(n):\n    # Intentional off-by-one bug: should sum 1..n inclusive\n    s = 0\n    for i in range(1, n + 1):\n        s += i\n    return s\n\ndef safe_divide(a, b):\n    # returns None when division by zero occurs, but we want 0 or raise\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return None\n\ndef find_max_index(values):\n    # returns index of max value; bug when values empty\n    max_i = 0\n    for i, v in enumerate(values):\n        if v > values[max_i]:\n            max_i = i\n    return max_i\n\n# Main entry\ndef main():\n    print(\"Starting Contact Manager Demo\")\n    demo_workflow()\n    print(\"\\n=== TEST HELPERS ===\")\n    print(\"Sum of first 10 (expect 55):\", sum_first_n(10))\n    print(\"Safe divide 10/2:\", safe_divide(10, 2))\n    print(\"Safe divide 10/0:\", safe_divide(10, 0))\n    print(\"Max index of [3,1,4,2]:\", find_max_index([3,1,4,2]))\n    try:\n        print(\"Max index of []:\", find_max_index([]))\n    except Exception as e:\n        print(\"Handled exception for empty list:\", e)\n\nif __name__ == \"__main__\":\n    main()\n",
  "iterations": [
    {
      "iteration": 1,
      "error_type": "LogicalError",
      "line_number": 244,
      "error_message": "Function 'sum_first_n' uses range(1, n) which excludes n - possible off-by-one error",
      "selected_patch_id": "logical_patch_1",
      "description": "Fix off-by-one error: change range(1, n) to range(1, n + 1) in sum_first_n()",
      "patch_score": 110,
      "status": "retrying",
      "returncode": 0,
      "backup_path": "backend/tests/new_test_code.py.backup"
    },
    {
      "iteration": 2,
      "error_type": null,
      "line_number": null,
      "error_message": null,
      "selected_patch_id": null,
      "description": "Code executed successfully with valid logic",
      "status": "fixed",
      "returncode": 0
    }
  ],
  "total_iterations": 2,
  "final_status": "success",
  "reason": "Code successfully repaired and executes without errors"
}