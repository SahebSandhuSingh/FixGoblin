{
  "metadata": {
    "file_path": "backend/tests/multi_line_buggy.py",
    "timestamp": "2025-11-27T20:03:16.341477",
    "execution_time_seconds": 1764253996.34,
    "total_iterations": 2
  },
  "status": {
    "emoji": "âŒ",
    "text": "Failed",
    "success": false,
    "final_status": "failed"
  },
  "errors": {
    "detected_types": [
      "IndexError"
    ],
    "count": 1
  },
  "patches": {
    "applied_count": 1,
    "summaries": [
      {
        "iteration": 1,
        "patch_id": "patch_1",
        "description": "Add boundary check before array access",
        "score": -30,
        "error_type": "IndexError",
        "line_number": 47
      }
    ]
  },
  "code_changes": {
    "diff": [
      "--- original",
      "+++ patched",
      "@@ -44,7 +44,8 @@",
      "     n = len(nums)",
      "     for i in range(n):",
      "         for j in range(0, n - i):  # should be n-i-1",
      "-            if nums[j] > nums[j + 1]:",
      "+            if j < len(nums):",
      "+                if nums[j] > nums[j + 1]:",
      "                 nums[j], nums[j+1] = nums[j+1], nums[j]",
      "     return nums",
      ""
    ],
    "lines_changed": 3,
    "original_lines": 304,
    "final_lines": 305
  },
  "logs": {
    "stdout": [],
    "stderr": []
  },
  "original_code": "# Buggy Python sample - 300 lines, many intentional bugs sprinkled\n# Author: Generated for testing\n# Purpose: include intentional bugs across the file\n\nimport math\nimport random\nfrom typing import List, Dict, Any\n\ndef safe_add(a, b):\n    \"\"\"Return the sum of a and b\"\"\"\n    return a + b\n\ndef buggy_division(a, b):\n    # Intentionally missing check for zero\n    return a / b\n\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nclass Counter:\n    def __init__(self, start=0):\n        self.value = start\n\n    def inc(self):\n        self.value += 1\n\n    def get(self):\n        return self.value\n\n# End of block 1\n\n\ndef find_max(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError(\"Empty list\")\n    max_v = nums[0]\n    for n in nums:\n        if n > max_v:\n            max_v = n\n    return max_v\n\ndef buggy_sort(nums: List[int]) -> List[int]:\n    # A buggy bubble sort with an off-by-one\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i):  # should be n-i-1\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):  # bug: math.sqrt returns float (logic note)\n        if n % i == 0:\n            return False\n    return True\n\n# helper\ndef identity(x): return x\n\n\ndef generate_sequence(n: int) -> List[int]:\n    seq = []\n    for i in range(n):\n        seq.append(i * i)\n    return seq\n\ndef buggy_merge(a: List[int], b: List[int]) -> List[int]:\n    # Merge assuming a and b sorted, but uses wrong indices\n    i, j = 0, 0\n    out = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            out.append(a[i])\n            i += 1\n        else:\n            out.append(b[j])\n            j += 1\n    # remaining\n    while i <= len(a):  # bug: should be < len(a)\n        out.append(a[i])\n        i += 1\n    while j < len(b):\n        out.append(b[j])\n        j += 1\n    return out\n\ndef format_point(x, y):\n    return f\"({x},{y})\"\n\n# End of block 3\n\n\nclass Person:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    def birthday(self):\n        self.age += 1\n\n    def __repr__(self):\n        return f\"Person({self.name}, {self.age})\"\n\ndef parse_int(s: str) -> int:\n    try:\n        return int(s)\n    except ValueError:\n        return None  # bug: should raise or return a sentinel (None changes type expectations)\n\ndef buggy_counter_factory(n):\n    funcs = []\n    for i in range(n):\n        def f():\n            return i  # bug: late binding captures i (all functions will return n-1)\n        funcs.append(f)\n    return funcs\n\n# small util\ndef noop(): pass\n\n\ndef compute_stats(nums: List[float]) -> Dict[str, float]:\n    if not nums:\n        return {\"mean\": 0.0, \"min\": 0.0, \"max\": 0.0}\n    s = sum(nums)\n    mean = s / len(nums)\n    return {\"mean\": mean, \"min\": min(nums), \"max\": max(nums)}\n\ndef buggy_power(x, y):\n    # mistakenly uses multiplication instead of exponent\n    return x * y\n\ndef fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\ndef buggy_map(func, items):\n    out = []\n    for i in items:\n        out.append(func)  # bug: should call func(i)\n    return out\n\n# formatting\ndef pretty(s):\n    return str(s).upper()\n\n\n# I/O helpers (no real I/O to keep this self contained)\ndef read_config() -> Dict[str, Any]:\n    # pretend config\n    return {\"retries\": 3, \"timeout\": 5}\n\ndef buggy_path_join(a, b):\n    # uses + without separator\n    return a + b\n\ndef serialize(obj):\n    # naive serializer\n    try:\n        return str(obj)\n    except Exception as e:\n        return \"{}\"\n\ndef buggy_deserialize(s):\n    # assumes eval is safe (it's not) and typo\n    return ecal(s)  # bug: misspelled eval -> NameError\n\ndef clamp(x, low, high):\n    return max(low, min(x, high))\n\ndef buggy_shuffle(lst):\n    # tries to use random.shuffle incorrectly\n    return random.shuffle(lst)  # bug: shuffle returns None (in-place)\n\n# End block\n\n\ndef compute_factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Negative\")\n    res = 1\n    for i in range(1, n+1):\n        res *= i\n    return res\n\ndef buggy_linear_search(arr, target):\n    # returns incorrect index when found at position 0\n    for i in range(1, len(arr)):  # bug: starts at 1, misses index 0\n        if arr[i] == target:\n            return i\n    return -1\n\ndef compose(f, g):\n    return lambda x: f(g(x))\n\ndef buggy_counter():\n    # mutable default trap\n    def add(item, lst=[]):\n        lst.append(item)\n        return lst\n    return add\n\n# small dataset\nSAMPLE = [3, 1, 4, 1, 5, 9, 2, 6]\n\n\ndef analyze_text(text: str) -> Dict[str, int]:\n    words = text.split()\n    counts = {}\n    for w in words:\n        counts[w] = counts.get(w, 0) + 1\n    return counts\n\ndef buggy_replace(s, a, b):\n    # uses wrong method name\n    return s.repace(a, b)  # bug: misspelled replace -> AttributeError\n\ndef to_celsius(f):\n    return (f - 32) * 5 / 9\n\ndef buggy_average(nums):\n    # divides by wrong variable\n    return sum(nums) / n  # bug: n undefined -> NameError\n\ndef repeat(s, n):\n    return s * n\n\n# End block\n\n\ndef buggy_unpack(tup):\n    # expects two but may get three\n    a, b = tup  # bug: ValueError if tup has !=2\n    return a, b\n\n\ndef connect_simulated(host: str, port: int):\n    # fake connection object\n    return {\"host\": host, \"port\": port, \"status\": \"connected\"}\n\ndef buggy_send(packet):\n    # tries to index a dict like a list\n    return packet[0]  # bug: may raise KeyError or TypeError depending on packet type\n\nclass Widget:\n    def __init__(self, name):\n        self.name = name\n\n    def render(self):\n        return f\"<widget>{self.name}</widget>\"\n\ndef buggy_time_sleep(sec):\n    # typo in function name\n    tim.sleep(sec)  # bug: module name typo -> NameError\n\n# small math\ndef hypotenuse(a, b):\n    return math.sqrt(a*a + b*b)\n\n\ndef buggy_pow(a, b):\n    # uses loop but off-by-one\n    res = 1\n    for i in range(1, b):  # bug: starts at 1, gives a^(b-1)\n        res *= a\n    return res\n\n\ndef main():\n    print(\"Starting test script\")\n\n    # test addition\n    print(\"2+3=\", safe_add(2, 3))\n\n    # test division (this will raise if b==0)\n    try:\n        print(\"10/2=\", buggy_division(10, 2))\n    except Exception as e:\n        print(\"Division error:\", e)\n\n    # test sort\n    data = [5, 3, 1, 4, 2]\n    print(\"Sorted:\", buggy_sort(data.copy()))\n\n    # test prime\n    print(\"7 is prime?\", is_prime(7))\n\n    # test merge\n    print(\"Merge:\", buggy_merge([1,3,5], [2,4,6]))\n\n    # test counter factory\n    funcs = buggy_counter_factory(3)\n    print(\"counter factory outputs:\", [f() for f in funcs])\n\n    # more tests\n    print(\"Done\")\n\nif __name__ == \"__main__\":\n    main()",
  "final_code": "# Buggy Python sample - 300 lines, many intentional bugs sprinkled\n# Author: Generated for testing\n# Purpose: include intentional bugs across the file\n\nimport math\nimport random\nfrom typing import List, Dict, Any\n\ndef safe_add(a, b):\n    \"\"\"Return the sum of a and b\"\"\"\n    return a + b\n\ndef buggy_division(a, b):\n    # Intentionally missing check for zero\n    return a / b\n\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nclass Counter:\n    def __init__(self, start=0):\n        self.value = start\n\n    def inc(self):\n        self.value += 1\n\n    def get(self):\n        return self.value\n\n# End of block 1\n\n\ndef find_max(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError(\"Empty list\")\n    max_v = nums[0]\n    for n in nums:\n        if n > max_v:\n            max_v = n\n    return max_v\n\ndef buggy_sort(nums: List[int]) -> List[int]:\n    # A buggy bubble sort with an off-by-one\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i):  # should be n-i-1\n            if j < len(nums):\n                if nums[j] > nums[j + 1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):  # bug: math.sqrt returns float (logic note)\n        if n % i == 0:\n            return False\n    return True\n\n# helper\ndef identity(x): return x\n\n\ndef generate_sequence(n: int) -> List[int]:\n    seq = []\n    for i in range(n):\n        seq.append(i * i)\n    return seq\n\ndef buggy_merge(a: List[int], b: List[int]) -> List[int]:\n    # Merge assuming a and b sorted, but uses wrong indices\n    i, j = 0, 0\n    out = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            out.append(a[i])\n            i += 1\n        else:\n            out.append(b[j])\n            j += 1\n    # remaining\n    while i <= len(a):  # bug: should be < len(a)\n        out.append(a[i])\n        i += 1\n    while j < len(b):\n        out.append(b[j])\n        j += 1\n    return out\n\ndef format_point(x, y):\n    return f\"({x},{y})\"\n\n# End of block 3\n\n\nclass Person:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    def birthday(self):\n        self.age += 1\n\n    def __repr__(self):\n        return f\"Person({self.name}, {self.age})\"\n\ndef parse_int(s: str) -> int:\n    try:\n        return int(s)\n    except ValueError:\n        return None  # bug: should raise or return a sentinel (None changes type expectations)\n\ndef buggy_counter_factory(n):\n    funcs = []\n    for i in range(n):\n        def f():\n            return i  # bug: late binding captures i (all functions will return n-1)\n        funcs.append(f)\n    return funcs\n\n# small util\ndef noop(): pass\n\n\ndef compute_stats(nums: List[float]) -> Dict[str, float]:\n    if not nums:\n        return {\"mean\": 0.0, \"min\": 0.0, \"max\": 0.0}\n    s = sum(nums)\n    mean = s / len(nums)\n    return {\"mean\": mean, \"min\": min(nums), \"max\": max(nums)}\n\ndef buggy_power(x, y):\n    # mistakenly uses multiplication instead of exponent\n    return x * y\n\ndef fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\ndef buggy_map(func, items):\n    out = []\n    for i in items:\n        out.append(func)  # bug: should call func(i)\n    return out\n\n# formatting\ndef pretty(s):\n    return str(s).upper()\n\n\n# I/O helpers (no real I/O to keep this self contained)\ndef read_config() -> Dict[str, Any]:\n    # pretend config\n    return {\"retries\": 3, \"timeout\": 5}\n\ndef buggy_path_join(a, b):\n    # uses + without separator\n    return a + b\n\ndef serialize(obj):\n    # naive serializer\n    try:\n        return str(obj)\n    except Exception as e:\n        return \"{}\"\n\ndef buggy_deserialize(s):\n    # assumes eval is safe (it's not) and typo\n    return ecal(s)  # bug: misspelled eval -> NameError\n\ndef clamp(x, low, high):\n    return max(low, min(x, high))\n\ndef buggy_shuffle(lst):\n    # tries to use random.shuffle incorrectly\n    return random.shuffle(lst)  # bug: shuffle returns None (in-place)\n\n# End block\n\n\ndef compute_factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Negative\")\n    res = 1\n    for i in range(1, n+1):\n        res *= i\n    return res\n\ndef buggy_linear_search(arr, target):\n    # returns incorrect index when found at position 0\n    for i in range(1, len(arr)):  # bug: starts at 1, misses index 0\n        if arr[i] == target:\n            return i\n    return -1\n\ndef compose(f, g):\n    return lambda x: f(g(x))\n\ndef buggy_counter():\n    # mutable default trap\n    def add(item, lst=[]):\n        lst.append(item)\n        return lst\n    return add\n\n# small dataset\nSAMPLE = [3, 1, 4, 1, 5, 9, 2, 6]\n\n\ndef analyze_text(text: str) -> Dict[str, int]:\n    words = text.split()\n    counts = {}\n    for w in words:\n        counts[w] = counts.get(w, 0) + 1\n    return counts\n\ndef buggy_replace(s, a, b):\n    # uses wrong method name\n    return s.repace(a, b)  # bug: misspelled replace -> AttributeError\n\ndef to_celsius(f):\n    return (f - 32) * 5 / 9\n\ndef buggy_average(nums):\n    # divides by wrong variable\n    return sum(nums) / n  # bug: n undefined -> NameError\n\ndef repeat(s, n):\n    return s * n\n\n# End block\n\n\ndef buggy_unpack(tup):\n    # expects two but may get three\n    a, b = tup  # bug: ValueError if tup has !=2\n    return a, b\n\n\ndef connect_simulated(host: str, port: int):\n    # fake connection object\n    return {\"host\": host, \"port\": port, \"status\": \"connected\"}\n\ndef buggy_send(packet):\n    # tries to index a dict like a list\n    return packet[0]  # bug: may raise KeyError or TypeError depending on packet type\n\nclass Widget:\n    def __init__(self, name):\n        self.name = name\n\n    def render(self):\n        return f\"<widget>{self.name}</widget>\"\n\ndef buggy_time_sleep(sec):\n    # typo in function name\n    tim.sleep(sec)  # bug: module name typo -> NameError\n\n# small math\ndef hypotenuse(a, b):\n    return math.sqrt(a*a + b*b)\n\n\ndef buggy_pow(a, b):\n    # uses loop but off-by-one\n    res = 1\n    for i in range(1, b):  # bug: starts at 1, gives a^(b-1)\n        res *= a\n    return res\n\n\ndef main():\n    print(\"Starting test script\")\n\n    # test addition\n    print(\"2+3=\", safe_add(2, 3))\n\n    # test division (this will raise if b==0)\n    try:\n        print(\"10/2=\", buggy_division(10, 2))\n    except Exception as e:\n        print(\"Division error:\", e)\n\n    # test sort\n    data = [5, 3, 1, 4, 2]\n    print(\"Sorted:\", buggy_sort(data.copy()))\n\n    # test prime\n    print(\"7 is prime?\", is_prime(7))\n\n    # test merge\n    print(\"Merge:\", buggy_merge([1,3,5], [2,4,6]))\n\n    # test counter factory\n    funcs = buggy_counter_factory(3)\n    print(\"counter factory outputs:\", [f() for f in funcs])\n\n    # more tests\n    print(\"Done\")\n\nif __name__ == \"__main__\":\n    main()"
}